var documenterSearchIndex = {"docs":
[{"location":"#ArrayAssemblers.jl-Documentation","page":"ArrayAssemblers.jl Documentation","title":"ArrayAssemblers.jl Documentation","text":"","category":"section"},{"location":"","page":"ArrayAssemblers.jl Documentation","title":"ArrayAssemblers.jl Documentation","text":"block(x)\nblock(f,x)\nlolcat(x)","category":"page"},{"location":"#ArrayAssemblers.block-Tuple{Any}","page":"ArrayAssemblers.jl Documentation","title":"ArrayAssemblers.block","text":"block(f, c...)\n\nEquivalent to block(map(f, c...)). Implements flatmap behavior.\n\nExample\n\njulia> Zn = [x for n in 1:3 for x in -n:2:n]\n9-element Vector{Int64}:\n -1\n  1\n -2\n  0\n  2\n -3\n -1\n  1\n  3\n\njulia> block(n -> -n:2:n, 1:3) == Zn\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#ArrayAssemblers.block-Tuple{Any, Any}","page":"ArrayAssemblers.jl Documentation","title":"ArrayAssemblers.block","text":"block(f, c...)\n\nEquivalent to block(map(f, c...)). Implements flatmap behavior.\n\nExample\n\njulia> Zn = [x for n in 1:3 for x in -n:2:n]\n9-element Vector{Int64}:\n -1\n  1\n -2\n  0\n  2\n -3\n -1\n  1\n  3\n\njulia> block(n -> -n:2:n, 1:3) == Zn\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#ArrayAssemblers.lolcat-Tuple{Any}","page":"ArrayAssemblers.jl Documentation","title":"ArrayAssemblers.lolcat","text":"lolcat(list_of_lists)\n\nAssembles a tensor of order ndim from a nested array-of-arrays. Vector sizes must match.\n\nSame as stack(x) for simple arrays-of-arrays. With more levels of nested collections, lolcat traverses the input like a tree, ceating new dimensions for each level.\n\nExamples\n\njulia> lolcat([[[1,2],[3,4]], [[5,6],[7,8]]])\n2×2×2 Array{Int64, 3}:\n[:, :, 1] =\n 1  3\n 2  4\n\n[:, :, 2] =\n 5  7\n 6  8\n\njulia> a = eachcol(reshape(1:6,2,:))\n3-element ColumnSlices{Base.ReshapedArray{Int64, 2, UnitRange{Int64}, Tuple{}}, Tuple{Base.OneTo{Int64}}, SubArray{Int64, 1, Base.ReshapedArray{Int64, 2, UnitRange{Int64}, Tuple{}}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}}:\n [1, 2]\n [3, 4]\n [5, 6]\n\njulia> lolcat(a)\n2×3 Matrix{Int64}:\n 1  3  5\n 2  4  6\n\njulia> lolcat((j,k) for j in 1:4, k in 5:6) do (j,k)\n                  [j, (j+k)÷2, k]\n              end\n3×4×2 Array{Int64, 3}:\n[:, :, 1] =\n 1  2  3  4\n 3  3  4  4\n 5  5  5  5\n\n[:, :, 2] =\n 1  2  3  4\n 3  4  4  5\n 6  6  6  6\n\nMore Examples\n\nTensor with rank 3 using do-syntax and nested map calls.\n\njulia> myxor = lolcat(0:1) do c\n           map(0:7) do b\n               map(0:3) do a\n                   xor(a,b,c)\n               end\n           end\n       end\n4×8×2 Array{Int64, 3}:\n[:, :, 1] =\n 0  1  2  3  4  5  6  7\n 1  0  3  2  5  4  7  6\n 2  3  0  1  6  7  4  5\n 3  2  1  0  7  6  5  4\n\n[:, :, 2] =\n 1  0  3  2  5  4  7  6\n 0  1  2  3  4  5  6  7\n 3  2  1  0  7  6  5  4\n 2  3  0  1  6  7  4  5\n\njulia> myxor == [xor(a,b,c) for a in 0:3, b in 0:7, c in 0:1]\ntrue\n\nStacking images. (Same behavior as stack.)\n\nusing TestImages, ImageView\nmyimages = [\"cameraman\", \"plastic_bubbles_he_512\", \"woman_darkhair\", \"resolution_test_512\", \"pirate\", \"walkbridge\"]\nimshow(Gray.(lolcat(testimage.(myimages[:]))))\n\n\n\n\n\n","category":"method"}]
}
