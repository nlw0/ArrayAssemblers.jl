var documenterSearchIndex = {"docs":
[{"location":"#ArrayAssemblers.jl-Documentation","page":"ArrayAssemblers.jl Documentation","title":"ArrayAssemblers.jl Documentation","text":"","category":"section"},{"location":"","page":"ArrayAssemblers.jl Documentation","title":"ArrayAssemblers.jl Documentation","text":"block(x)\nblock(f,x)\nlolcat(x)","category":"page"},{"location":"#ArrayAssemblers.block-Tuple{Any}","page":"ArrayAssemblers.jl Documentation","title":"ArrayAssemblers.block","text":"block(array_of_arrays)\n\nConcatenates a multi-dimensional array of arrays into a single array, seeing the input as a block array. The dimensions of the sub-arrays must match accordingly.\n\nExamples\n\nSimple concatenation of vectors\n\njulia> reduce(hcat, [[1,2,3], [4,5,6]])\n3×2 Matrix{Int64}:\n 1  4\n 2  5\n 3  6\n\njulia> block(reshape([[1,2,3], [4,5,6]], 1, :))\n6-element Vector{Int64}:\n 1  4\n 2  5\n 3  6\n\njulia> block([[1,2,3], [4,5,6]])\n6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n\njulia> vcat([1,2,3]', [4,5,6]')\n3×2 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\njulia> block([[1,2,3]', [4,5,6]'])\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\njulia> block([[1,2,3], [4,5,6]]')\n1×6 Matrix{Int64}:\n 1  2  3  4  5  6\n\n\"Flatmap\" behavior.\n\njulia> block(n -> -n:2:n, 1:3)\n9-element Vector{Int64}:\n -1\n  1\n -2\n  0\n  2\n -3\n -1\n  1\n  3\n\nImage montage.\n\nusing TestImages, ImageView\nmyimages = [\"cameraman\" \"plastic_bubbles_he_512\" \"woman_darkhair\"; \"resolution_test_512\" \"pirate\" \"walkbridge\"]\nimshow(block(testimage.(myimages)))\n\nExtended Help\n\nMore Examples\n\nHigher-dimension concatenation.\n\njulia> block([1 2]) do n reshape(n*4-3:n*4, 2, 2) end\n2×4 Matrix{Int64}:\n 1  3  5  7\n 2  4  6  8\n\njulia> block([1, 2]) do n reshape(n*4-3:n*4, 2, 2) end\n4×2 Matrix{Int64}:\n 1  3\n 2  4\n 5  7\n 6  8\n\njulia> block([1;;; 2;;;]) do n reshape(n*4-3:n*4, 2, 2) end\n2×2×2 Array{Int64, 3}:\n[:, :, 1] =\n 1  3\n 2  4\n\n[:, :, 2] =\n 5  7\n 6  8\n\nRelationship to eachcol and eachrow.\n\njulia> m = reshape(1:15,3,5)\n3×5 reshape(::UnitRange{Int64}, 3, 5) with eltype Int64:\n 1  4  7  10  13\n 2  5  8  11  14\n 3  6  9  12  15\n\njulia> lol = eachcol(m) |> collect\n5-element Vector{SubArray{Int64, 1, Base.ReshapedArray{Int64, 2, UnitRange{Int64}, Tuple{}}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}}:\n [1, 2, 3]\n [4, 5, 6]\n [7, 8, 9]\n [10, 11, 12]\n [13, 14, 15]\n\njulia> block(lol)\n15-element Vector{Int64}:\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n\njulia> block(lol')\n1×15 Matrix{Int64}:\n 1  2  3  4  5  6  7  8  9  10  11  12  13  14  15\n\njulia> block(permutedims(lol))\n3×5 Matrix{Int64}:\n 1  4  7  10  13\n 2  5  8  11  14\n 3  6  9  12  15\n\njulia> lol = eachrow(m) |> collect\n3-element Vector{SubArray{Int64, 1, Base.ReshapedArray{Int64, 2, UnitRange{Int64}, Tuple{}}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}}, true}}:\n [1, 4, 7, 10, 13]\n [2, 5, 8, 11, 14]\n [3, 6, 9, 12, 15]\n\njulia> block(permutedims(lol))\n5×3 Matrix{Int64}:\n  1   2   3\n  4   5   6\n  7   8   9\n 10  11  12\n 13  14  15\n\njulia> block(permutedims.(lol))\n3×5 Matrix{Int64}:\n 1  4  7  10  13\n 2  5  8  11  14\n 3  6  9  12  15\n\nNon-uniform array shapes with 3 dimensions.\n\njulia> myarrays = map([(j,k,l) for j in 1:2, k in 1:2, l in 1:2]) do (jkl)\n           reshape(1:prod((jkl)), jkl...)\n       end\n2×2×2 Array{Base.ReshapedArray{Int64, 3, UnitRange{Int64}, Tuple{}}, 3}:\n[:, :, 1] =\n [1;;;]     [1 2;;;]\n [1; 2;;;]  [1 3; 2 4;;;]\n\n[:, :, 2] =\n [1;;; 2]        [1 2;;; 3 4]\n [1; 2;;; 3; 4]  [1 3; 2 4;;; 5 7; 6 8]\n\njulia> arr = block(myarrays)\n3×3×3 Array{Int64, 3}:\n[:, :, 1] =\n 1  1  2\n 1  1  3\n 2  2  4\n\n[:, :, 2] =\n 1  1  2\n 1  1  3\n 2  2  4\n\n[:, :, 3] =\n 2  3  4\n 3  5  7\n 4  6  8\n\njulia> arr == block([(j,k,l) for j in 1:2, k in 1:2, l in 1:2]) do (jkl)\n           reshape(1:prod((jkl)), jkl...)\n       end\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#ArrayAssemblers.block-Tuple{Any, Any}","page":"ArrayAssemblers.jl Documentation","title":"ArrayAssemblers.block","text":"block(f, c...)\n\nEquivalent to block(map(f, c...)). Implements flatmap behavior.\n\nExample\n\njulia> Zn = [x for n in 1:3 for x in -n:2:n]\n9-element Vector{Int64}:\n -1\n  1\n -2\n  0\n  2\n -3\n -1\n  1\n  3\n\njulia> block(n -> -n:2:n, 1:3) == Zn\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#ArrayAssemblers.lolcat-Tuple{Any}","page":"ArrayAssemblers.jl Documentation","title":"ArrayAssemblers.lolcat","text":"lolcat(list_of_lists)\n\nAssembles a tensor of order ndim from a nested array-of-arrays. Vector sizes must match.\n\nExamples\n\njulia> lolcat([[[1,2],[3,4]], [[5,6],[7,8]]])\n2×2×2 Array{Int64, 3}:\n[:, :, 1] =\n 1  3\n 2  4\n\n[:, :, 2] =\n 5  7\n 6  8\n\njulia> a = eachcol(reshape(1:6,2,:))\n3-element ColumnSlices{Base.ReshapedArray{Int64, 2, UnitRange{Int64}, Tuple{}}, Tuple{Base.OneTo{Int64}}, SubArray{Int64, 1, Base.ReshapedArray{Int64, 2, UnitRange{Int64}, Tuple{}}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}}:\n [1, 2]\n [3, 4]\n [5, 6]\n\njulia> lolcat(a)\n2×3 Matrix{Int64}:\n 1  3  5\n 2  4  6\n\njulia> lolcat((j,k) for j in 1:4, k in 5:6) do (j,k)\n                  [j, (j+k)÷2, k]\n              end\n3×4×2 Array{Int64, 3}:\n[:, :, 1] =\n 1  2  3  4\n 3  3  4  4\n 5  5  5  5\n\n[:, :, 2] =\n 1  2  3  4\n 3  4  4  5\n 6  6  6  6\n\n\n\n\n\n","category":"method"}]
}
